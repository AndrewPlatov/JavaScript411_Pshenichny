# Идея декоратора

# def get_number_from_user():
#     return int(input('Введите число: '))
# answer = None
# try:                                    # отсюда пошло исключение
#     answer = get_number_from_user()
# except:
#     print('Это не число...')

# ! Каждый раз при использовании функции get_number_from_user придётся использовать подобную конструкцию.

# --------------------------------------------------------------------------------------------------------------- #

# Функцию можно присвоить переменной. Переменная становится "вызываемой" (callable) - это можно проверить 
# с помощью функции проверки или просто вызвать переменную, которая теперь функция.

# печать = print
# печать("Я умею печатать")
# callable(печать) # проверка что печать является функцией 

# --------------------------------------------------------------------------------------------------------------- #

# Измеряем время

# Пусть есть функция, которая выполняется долго. Т.е. не мгновенно, а
# несколько секунд

# Декоратор - КАК? Шаг 1
from datetime import datetime, timezone

def measure_time():
    dt_start = datetime.now(timezone.utc)
    multiplication()
    dt_end = datetime.now(timezone.utc)
    print(dt_end - dt_start)
    
# Теперь есть способ измерить время работы... РОВНО ОДНОЙ ФУНКЦИИ. 
# Будет ли отличаться измерение времени для других функций? НЕТ!

def multiplication():
    for i in range(10**8):  # 100 миллионов умножений
        6.9 * 7.3
    print('Долгая функция закончилась')
    return 789

measure_time()

# --------------------------------------------------------------------------------------------------------------- #